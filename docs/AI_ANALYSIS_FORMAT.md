# AI Analysis Data Format

This document describes the comprehensive data format generated by Manito's AI analysis endpoint (`/api/ai/analyze`) that can be consumed by AI tools to generate valuable insights about codebases.

## Overview

The AI analysis endpoint generates a structured JSON response containing detailed information about a codebase's architecture, dependencies, quality metrics, and potential issues. This data can be used by AI tools to:

- Generate interactive visualizations
- Provide architectural recommendations
- Identify code quality issues
- Suggest refactoring opportunities
- Analyze security vulnerabilities
- Assess technical debt

## API Endpoint

```
POST /api/ai/analyze
Content-Type: application/json

{
  "path": "./path/to/project",
  "options": {
    "patterns": ["**/*.js", "**/*.ts", "**/*.jsx", "**/*.tsx"],
    "excludePatterns": ["node_modules/**", "dist/**", "build/**"]
  }
}
```

## Response Format

The response contains a comprehensive data structure with the following sections:

### 1. Metadata

```json
{
  "metadata": {
    "projectName": "string",
    "version": "string",
    "scanTimestamp": "ISO-8601 timestamp",
    "totalFiles": "number",
    "totalLines": "number",
    "totalDependencies": "number",
    "projectType": "string",
    "framework": "string",
    "buildTools": ["array of strings"]
  }
}
```

**Use Cases for AI Tools:**
- Project overview and context
- Technology stack identification
- Scale assessment
- Historical tracking

### 2. Dependency Graph

```json
{
  "dependencyGraph": {
    "nodes": [
      {
        "id": "file path",
        "label": "file name",
        "type": "file type",
        "metrics": {
          "size": "number",
          "lines": "number",
          "complexity": "number",
          "functions": "number",
          "variables": "number",
          "imports": "number",
          "exports": "number",
          "dependencyCount": "number",
          "fanIn": "number",
          "fanOut": "number"
        },
        "properties": {
          "isTypeScript": "boolean",
          "isJSX": "boolean",
          "isTest": "boolean",
          "isConfig": "boolean",
          "category": "string"
        }
      }
    ],
    "edges": [
      {
        "id": "unique edge id",
        "source": "source file path",
        "target": "target file path",
        "type": "dependency type",
        "properties": {
          "isCircular": "boolean",
          "isExternal": "boolean",
          "strength": "number",
          "direction": "string"
        }
      }
    ],
    "clusters": [
      {
        "id": "cluster id",
        "files": ["array of file paths"],
        "size": "number",
        "cohesion": "number",
        "coupling": "number"
      }
    ],
    "layers": {
      "presentation": ["file paths"],
      "business": ["file paths"],
      "data": ["file paths"],
      "infrastructure": ["file paths"],
      "shared": ["file paths"]
    }
  }
}
```

**Use Cases for AI Tools:**
- Interactive dependency visualization
- Architecture pattern recognition
- Module boundary analysis
- Impact analysis for changes
- Circular dependency detection

### 3. Quality Metrics

```json
{
  "qualityMetrics": {
    "complexity": {
      "average": "number",
      "max": "number",
      "hotspots": [
        {
          "file": "file path",
          "complexity": "number",
          "lines": "number",
          "functions": "number"
        }
      ],
      "distribution": {
        "low": "number",
        "medium": "number",
        "high": "number",
        "critical": "number"
      }
    },
    "coupling": {
      "average": "number",
      "max": "number",
      "tightlyCoupled": [
        {
          "file": "file path",
          "coupling": "number"
        }
      ],
      "looselyCoupled": [
        {
          "file": "file path",
          "coupling": "number"
        }
      ]
    },
    "cohesion": {
      "highCohesion": ["file paths"],
      "lowCohesion": ["file paths"],
      "average": "number"
    },
    "maintainability": {
      "excellent": ["file paths"],
      "good": ["file paths"],
      "fair": ["file paths"],
      "poor": ["file paths"],
      "average": "number"
    },
    "technicalDebt": {
      "total": "number",
      "categories": {
        "complexity": "number",
        "duplication": "number",
        "violations": "number",
        "coverage": "number",
        "documentation": "number"
      },
      "hotspots": ["file paths"],
      "recommendations": ["array of recommendations"]
    }
  }
}
```

**Use Cases for AI Tools:**
- Code quality assessment
- Technical debt quantification
- Refactoring prioritization
- Maintainability scoring
- Complexity trend analysis

### 4. Issues and Conflicts

```json
{
  "issues": {
    "circularDependencies": [
      ["file1", "file2", "file3"]
    ],
    "deadCode": {
      "unusedFunctions": ["function names"],
      "unusedVariables": ["variable names"],
      "unusedImports": ["import statements"],
      "unreachableCode": ["code locations"]
    },
    "duplicatePatterns": [
      {
        "pattern": ["dependency1", "dependency2"],
        "files": ["file paths"],
        "count": "number"
      }
    ],
    "unusedDependencies": [
      {
        "file": "file path",
        "dependency": "dependency name",
        "type": "dependency type"
      }
    ],
    "securityVulnerabilities": {
      "high": ["vulnerabilities"],
      "medium": ["vulnerabilities"],
      "low": ["vulnerabilities"],
      "total": "number"
    },
    "performanceIssues": {
      "largeFiles": ["file paths"],
      "complexFunctions": ["function names"],
      "heavyDependencies": ["dependency names"],
      "inefficientPatterns": ["pattern descriptions"]
    }
  }
}
```

**Use Cases for AI Tools:**
- Issue prioritization
- Security scanning
- Performance optimization
- Code cleanup recommendations
- Risk assessment

### 5. Architecture Insights

```json
{
  "architecture": {
    "patterns": {
      "mvc": ["file paths"],
      "mvvm": ["file paths"],
      "layered": ["file paths"],
      "microservices": ["file paths"],
      "monolith": ["file paths"],
      "eventDriven": ["file paths"]
    },
    "boundaries": {
      "modules": [
        {
          "name": "module name",
          "path": "module path",
          "files": ["file paths"],
          "size": "number"
        }
      ],
      "interfaces": ["interface definitions"],
      "boundaries": ["boundary definitions"]
    },
    "interfaces": {
      "public": ["public interfaces"],
      "private": ["private interfaces"],
      "shared": ["shared interfaces"]
    },
    "dataFlow": {
      "patterns": ["data flow patterns"],
      "bottlenecks": ["bottleneck locations"],
      "flows": ["data flow descriptions"]
    },
    "stateManagement": {
      "patterns": ["state management patterns"],
      "stores": ["state stores"],
      "providers": ["state providers"]
    }
  }
}
```

**Use Cases for AI Tools:**
- Architecture pattern recognition
- Design pattern analysis
- Interface design recommendations
- Data flow optimization
- State management analysis

### 6. Recommendations

```json
{
  "recommendations": {
    "refactoring": [
      {
        "type": "refactoring type",
        "files": ["affected files"],
        "priority": "high|medium|low",
        "effort": "high|medium|low",
        "impact": "high|medium|low"
      }
    ],
    "optimization": [
      {
        "type": "optimization type",
        "description": "description",
        "priority": "high|medium|low",
        "effort": "high|medium|low",
        "impact": "high|medium|low"
      }
    ],
    "security": [
      {
        "type": "security recommendation type",
        "description": "description",
        "priority": "high|medium|low",
        "effort": "high|medium|low",
        "impact": "high|medium|low"
      }
    ],
    "testing": [
      {
        "type": "testing recommendation type",
        "description": "description",
        "priority": "high|medium|low",
        "effort": "high|medium|low",
        "impact": "high|medium|low"
      }
    ],
    "documentation": [
      {
        "type": "documentation recommendation type",
        "description": "description",
        "priority": "high|medium|low",
        "effort": "high|medium|low",
        "impact": "high|medium|low"
      }
    ]
  }
}
```

**Use Cases for AI Tools:**
- Actionable improvement suggestions
- Prioritized task lists
- ROI calculations
- Implementation planning
- Progress tracking

## AI Tool Integration Examples

### 1. Interactive Visualization

```javascript
// Example: Using the data with a graph visualization library
const response = await fetch('/api/ai/analyze', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ path: './my-project' })
});

const { data } = await response.json();

// Create interactive graph
const graph = new Graph({
  nodes: data.dependencyGraph.nodes,
  edges: data.dependencyGraph.edges,
  onNodeClick: (node) => showNodeDetails(node),
  onEdgeClick: (edge) => showDependencyDetails(edge)
});
```

### 2. Code Quality Dashboard

```javascript
// Example: Creating a quality metrics dashboard
const qualityData = data.qualityMetrics;

const dashboard = {
  complexity: {
    average: qualityData.complexity.average,
    hotspots: qualityData.complexity.hotspots,
    distribution: qualityData.complexity.distribution
  },
  maintainability: {
    score: qualityData.maintainability.average,
    breakdown: {
      excellent: qualityData.maintainability.excellent.length,
      good: qualityData.maintainability.good.length,
      fair: qualityData.maintainability.fair.length,
      poor: qualityData.maintainability.poor.length
    }
  }
};
```

### 3. AI-Powered Recommendations

```javascript
// Example: Using AI to generate contextual recommendations
const recommendations = data.recommendations;

const aiRecommendations = await aiService.analyze({
  context: {
    projectType: data.metadata.projectType,
    framework: data.metadata.framework,
    qualityMetrics: data.qualityMetrics,
    issues: data.issues
  },
  recommendations: recommendations,
  prompt: "Generate specific, actionable recommendations for improving this codebase"
});
```

### 4. Architecture Analysis

```javascript
// Example: Architecture pattern analysis
const architecture = data.architecture;

const patternAnalysis = {
  detectedPatterns: Object.keys(architecture.patterns).filter(
    pattern => architecture.patterns[pattern].length > 0
  ),
  moduleBoundaries: architecture.boundaries.modules,
  dataFlow: architecture.dataFlow,
  recommendations: generateArchitectureRecommendations(architecture)
};
```

## Best Practices for AI Tools

### 1. Data Processing

- **Normalize file paths**: Handle different path formats across operating systems
- **Cache results**: Store analysis results to avoid repeated scans
- **Incremental updates**: Only re-analyze changed files when possible
- **Error handling**: Gracefully handle missing or malformed data

### 2. Visualization

- **Progressive disclosure**: Show high-level overview first, then drill down
- **Color coding**: Use consistent colors for different file types and categories
- **Interactive elements**: Allow users to explore relationships and details
- **Performance**: Handle large codebases efficiently with pagination or virtualization

### 3. Recommendations

- **Context-aware**: Consider project type, framework, and team size
- **Prioritized**: Sort recommendations by impact and effort
- **Actionable**: Provide specific, implementable suggestions
- **Trackable**: Include metrics to measure improvement over time

### 4. Integration

- **API-first**: Design for programmatic access
- **Real-time**: Provide live updates during development
- **Collaborative**: Support team workflows and sharing
- **Extensible**: Allow custom analysis and visualization plugins

## Future Enhancements

The AI analysis format is designed to be extensible. Future versions may include:

- **Semantic analysis**: Understanding code meaning and intent
- **Performance profiling**: Runtime performance metrics
- **Security scanning**: Vulnerability detection and assessment
- **Documentation analysis**: Coverage and quality assessment
- **Test coverage**: Integration with testing frameworks
- **Git integration**: Historical analysis and trend tracking
- **Team insights**: Collaboration patterns and code ownership
- **Machine learning**: Predictive analysis and automated recommendations

## Conclusion

This AI analysis data format provides a comprehensive foundation for building intelligent code analysis tools. By leveraging this structured data, AI tools can generate valuable insights, provide actionable recommendations, and create interactive visualizations that help developers understand and improve their codebases.

The format is designed to be both human-readable and machine-processable, enabling a wide range of applications from simple dashboards to sophisticated AI-powered development assistants.
